### **1. 分割方式数（方案数统计）**
**问题本质**：计算将字符串分割成若干子串的所有合法方案数，其中每个子串的长度不能超过该子串中所有字符对应的最小限制值。  
**DP状态定义**：  
- `dp[i]` 表示前 `i` 个字符（即 `s[0..i-1]`）的合法分割方案数。  
**初始化**：  
- `dp[0] = 1`，表示空字符串有1种分割方案（即不分割）。  
**转移过程**：  
1. 遍历每个可能的起点 `i`（从 `0` 到 `n-1`）。  
2. 从 `i` 开始向后扩展子串 `s[i..j]`，并实时维护当前子串的最小限制值 `min_len`（即 `min(nums[s[i]], nums[s[i+1]], ..., nums[s[j]])`）。  
3. 如果子串长度 `j-i+1 > min_len`，说明子串非法，直接跳出循环。  
4. 否则，当前子串合法，将 `dp[i]` 的方案数累加到 `dp[j+1]` 上（即 `dp[j+1] += dp[i]`），并对结果取模防止溢出。  
**结果**：  
- `dp[n]` 即为整个字符串的合法分割方案数。  

---

### **2. 最长合法子串（最大值维护）**
**问题本质**：在所有合法的分割方案中，找到最长的那个子串的长度。  
**DP状态定义**：  
- `dp[i]` 表示前 `i` 个字符（即 `s[0..i-1]`）在合法分割下的最长子串长度。  
**初始化**：  
- `dp[0] = 0`，表示空字符串的最长子串长度为0。  
**转移过程**：  
1. 遍历每个起点 `i`（从 `0` 到 `n-1`）。  
2. 从 `i` 开始向后扩展子串 `s[i..j]`，维护当前子串的最小限制值 `min_len`。  
3. 如果子串长度 `j-i+1 > min_len`，跳出循环。  
4. 否则，更新 `dp[j+1]` 为以下两者的最大值：  
   - `dp[j+1]` 的当前值（即之前计算的结果）。  
   - `max(dp[i], j-i+1)`（即从 `i` 转移过来的最长子串长度，或当前子串的长度）。  
**结果**：  
- `dp[n]` 即为整个字符串的最长合法子串长度。  

---

### **3. 最少分割次数（最优化问题）**
**问题本质**：找到将字符串分割成若干合法子串所需的最少分割次数。  
**DP状态定义**：  
- `dp[i]` 表示分割前 `i` 个字符（即 `s[0..i-1]`）所需的最少分割次数。  
**初始化**：  
- `dp[0] = 0`，表示空字符串不需要分割。  
- 其他 `dp[i]` 初始化为 `n`（即一个足够大的值，表示初始不可达）。  
**转移过程**：  
1. 遍历每个起点 `i`（从 `0` 到 `n-1`）。  
2. 从 `i` 开始向后扩展子串 `s[i..j]`，维护当前子串的最小限制值 `min_len`。  
3. 如果子串长度 `j-i+1 > min_len`，跳出循环。  
4. 否则，更新 `dp[j+1]` 为 `min(dp[j+1], dp[i] + 1)`（即从 `i` 转移过来的分割次数加1）。  
**结果**：  
- `dp[n]` 即为整个字符串的最少分割次数。  

---

### **通俗理解与技巧总结**
1. **共同框架**：  
   - 三个问题都采用 **划分型DP** 的思路，即通过固定起点 `i`，向后扩展子串 `s[i..j]`，并检查合法性。  
   - 合法性检查：子串长度 `≤` 子串中所有字符的最小限制值。  
   - 一旦子串非法（长度超过限制），立即跳出循环，保证效率。  

2. **状态转移的区别**：  
   - **方案数**：累加所有合法的转移路径（`dp[j+1] += dp[i]`）。  
   - **最长子串**：维护最大值（`dp[j+1] = max(...)`）。  
   - **最少分割**：维护最小值（`dp[j+1] = min(...)`）。  

3. **初始化与边界**：  
   - 空字符串（`dp[0]`）的处理是关键，直接影响后续转移的正确性。  
   - 对于最值问题（最长/最少），初始值的设置需保证不影响后续比较（如 `INF` 或 `0`）。  

4. **时间复杂度**：  
   - 均为 `O(n²)`，因外层循环 `i` 遍历 `n` 次，内层循环 `j` 最多遍历 `n` 次（但通过提前跳出优化，实际运行更快）。  

---

### **总结**
- **划分型DP** 的经典三连问：方案数、最值、最优化。  
- **关键技巧**：固定起点扩展子串 + 实时维护限制条件 + 根据问题类型设计转移方程。  
- **代码实现**：注意初始化、边界条件、循环范围和状态转移的逻辑一致性。  
